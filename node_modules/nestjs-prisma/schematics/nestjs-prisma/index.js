"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nestjsPrismaAdd = void 0;
const npm_scripts_1 = require("./npm-scripts");
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const core_1 = require("@angular-devkit/core");
const get_latest_dependency_version_1 = require("./utils/get-latest-dependency-version");
const dependencies_2 = require("./dependencies");
// You don't have to export the function as default. You can also have more than one rule factory
// per file.
function nestjsPrismaAdd(_options) {
    return (_tree, _context) => {
        if (!_options.skipInstall) {
            _context.addTask(new tasks_1.NodePackageInstallTask());
        }
        return (0, schematics_1.chain)([
            addDependencies(dependencies_2.dependencies),
            addNpmScripts(),
            addSeedScript(),
            addPrismaService(_options),
            addDockerFile(_options),
            addDockerCompose(_options),
            excludePrismaFromBuild(),
            prismaInit(_options),
        ]);
    };
}
exports.nestjsPrismaAdd = nestjsPrismaAdd;
function addDependencies(dependencies) {
    return (tree, context) => {
        return Promise.all(dependencies.map((dependency) => (0, get_latest_dependency_version_1.getLatestDependencyVersion)(dependency.name).then(({ name, version }) => {
            context.logger.info(`✅️ Added ${name}@${version}`);
            const nodeDependency = {
                name,
                version,
                type: dependency.type,
            };
            (0, dependencies_1.addPackageJsonDependency)(tree, nodeDependency);
        }))).then(() => tree);
    };
}
function addNpmScripts() {
    return (tree, context) => {
        const pkgPath = 'package.json';
        const buffer = tree.read(pkgPath);
        if (buffer === null) {
            throw new schematics_1.SchematicsException(`Could not find ${pkgPath}.`);
        }
        const pkg = JSON.parse(buffer.toString());
        context.logger.info(`✅️ Added Prisma scripts [${npm_scripts_1.npmScripts.length}]`);
        npm_scripts_1.npmScripts.map((npmScript) => (pkg.scripts[npmScript.name] = npmScript.command));
        tree.overwrite(pkgPath, JSON.stringify(pkg, null, 2));
        return tree;
    };
}
function addSeedScript() {
    return (tree, context) => {
        const pkgPath = 'package.json';
        const buffer = tree.read(pkgPath);
        if (buffer === null) {
            throw new schematics_1.SchematicsException(`Could not find ${pkgPath}.`);
        }
        const pkg = JSON.parse(buffer.toString());
        context.logger.info(`✅️ Added Prisma Seed script`);
        pkg['prisma'] = { seed: 'ts-node prisma/seed.ts' };
        tree.overwrite(pkgPath, JSON.stringify(pkg, null, 2));
        return tree;
    };
}
function addPrismaService(_options) {
    return (_tree, context) => {
        if (_options.addPrismaService) {
            context.logger.info(`✅️ Added custom PrismaModule and PrismaService`);
            const sourceTemplates = (0, schematics_1.url)('./templates/services');
            const sourceParametrizedTemplates = (0, schematics_1.apply)(sourceTemplates, [
                (0, schematics_1.template)(Object.assign(Object.assign({}, _options), core_1.strings)),
            ]);
            return (0, schematics_1.mergeWith)(sourceParametrizedTemplates);
        }
        return _tree;
    };
}
function addDockerFile(_options) {
    return (_tree, context) => {
        if (_options.addDocker) {
            context.logger.info(`✅️ Added Docker file`);
            const sourceTemplates = (0, schematics_1.url)('./templates/docker/common');
            const sourceParametrizedTemplates = (0, schematics_1.apply)(sourceTemplates, [
                (0, schematics_1.template)(Object.assign(Object.assign({}, _options), core_1.strings)),
            ]);
            return (0, schematics_1.mergeWith)(sourceParametrizedTemplates);
        }
        return _tree;
    };
}
function addDockerCompose(_options) {
    return (_tree, context) => {
        if (_options.addDocker) {
            context.logger.info(`✅️ Added Docker Compose and .env`);
            if (_options.datasourceProvider === 'mysql' ||
                _options.datasourceProvider === 'postgresql') {
                _options.datasourceProvider;
                const sourceTemplates = (0, schematics_1.url)(`./templates/docker/${_options.datasourceProvider}`);
                const sourceParametrizedTemplates = (0, schematics_1.apply)(sourceTemplates, [
                    (0, schematics_1.template)(Object.assign(Object.assign({}, _options), core_1.strings)),
                ]);
                return (0, schematics_1.mergeWith)(sourceParametrizedTemplates);
            }
        }
        return _tree;
    };
}
function excludePrismaFromBuild() {
    return (tree, context) => {
        const tsconfigBuildPath = 'tsconfig.build.json';
        const buffer = tree.read(tsconfigBuildPath);
        if (buffer !== null) {
            context.logger.info(`✅️ Add "prisma" directory to "excludes" in ${tsconfigBuildPath}`);
            const tsconfig = JSON.parse(buffer.toString());
            tsconfig.exclude = [...tsconfig.exclude, 'prisma'];
            tree.overwrite(tsconfigBuildPath, JSON.stringify(tsconfig, null, 2));
        }
        return tree;
    };
}
function prismaInit(_options) {
    return (_tree, context) => {
        if (!_options.skipPrismaInit) {
            const packageInstall = context.addTask(new tasks_1.NodePackageInstallTask());
            context.addTask(new tasks_1.RunSchematicTask('prisma-init', {
                datasource: _options.datasourceProvider,
            }), [packageInstall]);
        }
        return _tree;
    };
}
//# sourceMappingURL=index.js.map